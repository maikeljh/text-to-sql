Question,Answer,Summary,Alternative Prompt 1 (English),Alternative Prompt 2 (Bahasa Indonesia),Expected Result
How much total revenue did we make in 1997? Show the result as 1997 Total Revenues.,SELECT SUM(od.unit_price * od.quantity * (1.0 - od.discount)) AS total_revenue_1997 FROM order_details od INNER JOIN orders o ON od.order_id = o.order_id WHERE EXTRACT(YEAR FROM o.order_date) = 1997;,"This SQL query calculates the total revenue generated in 1997 by summing the product of unit price, quantity, and discount-adjusted values from order details. It joins the 'order_details' and 'orders' tables on 'order_id' and filters for orders placed in 1997 using EXTRACT on the 'order_date' field. The primary metric is 'total_revenue_1997', which provides a key business performance indicator. The query could be modified by (1) grouping revenue by month or quarter to analyze seasonal trends, (2) adding product categories from a related table to break down revenue by product type, or (3) comparing 1997 revenue to other years by adjusting the WHERE clause. This query would help analysts answer questions about annual sales performance, year-over-year growth, and the effectiveness of discount strategies in 1997.",How much money did we make in 1997 total? Show it as '1997 Total Revenues'.,Total pendapatan kita tahun 1997 berapa sih? Tampilkan sebagai '1997 Total Revenues'.,['total_revenue_1997']
"List the top 3 employees who serve the most unique customers. Show first_name, last_name, and unique_customers.","SELECT e.first_name, e.last_name, COUNT(DISTINCT o.customer_id) AS unique_customers
FROM employees e
JOIN orders o ON e.employee_id = o.employee_id
GROUP BY e.employee_id, e.first_name, e.last_name
ORDER BY unique_customers DESC
LIMIT 3;","This SQL query identifies the top 3 employees with the most unique customers by joining the 'employees' and 'orders' tables. It counts distinct customer IDs per employee, groups by employee details, and sorts to highlight those with the broadest customer reach. The output helps evaluate sales team performance in customer acquisition and relationship diversity. Key operations include a table JOIN, COUNT(DISTINCT) for unique customer counting, and LIMIT to focus on top performers. The query can be modified to: 1) add date ranges to analyze customer acquisition trends, 2) include order value metrics to assess customer quality, or 3) filter by customer region to evaluate geographic coverage. It helps answer business questions like 'Which employees manage the most diverse customer portfolios?' and 'Who are our most effective customer relationship builders?'","Top 3 employees with the most distinct customers? Show 'first_name', 'last_name', 'unique_customers'.","Top 3 karyawan yang handle customer unik paling banyak? Tampilkan 'first_name', 'last_name', 'unique_customers'.","['first_name', 'last_name', 'unique_customers']"
Which top 1 country has the most suppliers? Show country and supplier_count.,"SELECT country, COUNT(*) AS supplier_count
  FROM suppliers
  GROUP BY country
  ORDER BY supplier_count DESC
  LIMIT 1;","This SQL query identifies the country with the highest number of suppliers by counting and grouping supplier records by country from the 'suppliers' table. It returns the top country based on supplier count in descending order. Key operations include COUNT aggregation, GROUP BY on country, and ORDER BY with LIMIT to isolate the top result. The primary metric 'supplier_count' reveals geographic concentration of suppliers. No filters are applied, providing a complete view of supplier distribution. The output helps identify primary sourcing locations, valuable for supply chain optimization and risk assessment. Potential modifications include: (1) adding a region filter to analyze supplier distribution within specific areas, (2) comparing supplier count against purchase volume by country, or (3) calculating the percentage of total suppliers each country represents. This query could answer questions like 'Which country hosts most of our suppliers?' or 'How geographically diverse is our supplier base?'",Which top 1 country has the most suppliers? Show 'country' and 'supplier_count'.,Top 1 negara mana yang punya supplier paling banyak? Tampilkan 'country' dan 'supplier_count'.,"['country', 'supplier_count']"
"Show the total amount of orders for each year/month. Show order_year, order_month, and no_of_orders.","SELECT
  EXTRACT(YEAR FROM order_date) AS order_year,
  EXTRACT(MONTH FROM order_date) AS order_month,
  COUNT(*) AS no_of_orders
FROM orders
GROUP BY order_year, order_month;","This SQL query analyzes monthly order trends by counting the number of orders per month across years. It extracts year and month components from the order_date in the 'orders' table, then groups and counts orders by these time periods. The output provides valuable insights into seasonal sales patterns and business growth trends. Key operations include EXTRACT for date part isolation, COUNT aggregation, and multi-column GROUP BY. The query can be modified to: 1) add revenue calculations to analyze monetary trends, 2) filter by product categories to identify seasonal items, or 3) compare year-over-year growth by adding percentage change calculations. It helps answer critical business questions like 'What are our busiest months?' and 'How is our order volume changing over time?'","Total orders per year and month? Show 'order_year', 'order_month', 'no_of_orders'.","Jumlah order per tahun dan bulan berapa aja? Tampilkan 'order_year', 'order_month', 'no_of_orders'.","['order_year', 'order_month', 'no_of_orders']"
"Which top 1 employee have handled the most orders? Show employee_id, first_name, last_name, and total_orders.","SELECT e.employee_id, e.first_name, e.last_name, COUNT(o.order_id) AS total_orders
  FROM employees e
  JOIN orders o ON e.employee_id = o.employee_id
  GROUP BY e.employee_id, e.first_name, e.last_name
  ORDER BY total_orders DESC
  LIMIT 1;","This SQL query identifies the top 1 employee by order volume by joining the 'employees' and 'orders' tables on employee_id, counting orders per employee, and sorting in descending order. Key operations include a simple JOIN, COUNT aggregation, and LIMIT for result restriction. The output highlights the most productive sales staff, useful for performance evaluation and incentive programs. Modifications could include: 1) adding date filters to analyze performance trends over time, 2) incorporating order value metrics to assess revenue impact, or 3) joining with territories data to evaluate regional performance. This query helps answer questions like 'Who are our most active sales employees?' and 'Which staff members handle the highest order volumes?'","Which top 1 employee handled the most orders? Show 'employee_id', 'first_name', 'last_name', 'total_orders'.","Top 1 Karyawan mana yang paling banyak urus order? Tampilkan 'employee_id', 'first_name', 'last_name', 'total_orders'.","['employee_id', 'first_name', 'last_name', 'total_orders']"
"What is the total number of discontinued products by category? Show category_id, category_name, and discontinued_count.","SELECT c.category_id, c.category_name, COUNT(p.product_id) AS discontinued_count
  FROM categories c
  JOIN products p ON c.category_id = p.category_id
  WHERE p.discontinued = 1
  GROUP BY c.category_id, c.category_name
  ORDER BY discontinued_count DESC;","This SQL query analyzes product discontinuation patterns by category by counting discontinued products in each category. It joins the 'categories' and 'products' tables, filters for discontinued products (discontinued = 1), and groups the results by category to show which categories have the most discontinued items. The output helps identify problematic product categories and informs inventory management decisions. Key operations include a table JOIN, COUNT aggregation with GROUP BY, and filtering on the discontinued flag. The query can be modified to: 1) include date discontinued to analyze trends over time, 2) add supplier information to identify problematic suppliers, or 3) calculate the percentage of discontinued products per category. It helps answer business questions like 'Which product categories have the highest discontinuation rates?' and 'Should we reconsider our offerings in certain categories?'","How many discontinued products are in each category? Show 'category_id', 'category_name', 'discontinued_count'.","Jumlah produk discontinue per kategori gimana? Tampilkan 'category_id', 'category_name', 'discontinued_count'.","['category_id', 'category_name', 'discontinued_count']"
What is the total freight cost per country? Show ship_country and total_freight.,"SELECT ship_country, SUM(freight) AS total_freight
  FROM orders
  GROUP BY ship_country
  ORDER BY total_freight DESC;","This SQL query calculates the total freight costs by country by aggregating the 'freight' column from the 'orders' table, grouped by 'ship_country' and sorted in descending order of total freight. The primary metric is the sum of freight costs ('total_freight') per destination country, providing a clear view of shipping expenditure distribution. No filters are applied, making it a comprehensive analysis of all orders. The output helps identify high-cost shipping destinations, useful for logistics optimization and cost management. Potential modifications include: (1) adding a date filter to analyze freight cost trends over time, (2) joining with customer data to calculate freight costs per customer segment, or (3) comparing freight costs against order values to assess shipping cost ratios. This query could answer questions like 'Which countries have the highest shipping costs?' or 'How do freight expenses distribute across our shipping destinations?'",Total freight costs per country? Show 'ship_country' and 'total_freight'.,Total ongkir per negara berapa aja? Tampilkan 'ship_country' dan 'total_freight'.,"['ship_country', 'total_freight']"
Show the total number of employees per region along with the region description. Show region_description and total_employees.,"SELECT r.region_description, COUNT(e.employee_id) AS total_employees
FROM region r
JOIN territories t ON r.region_id = t.region_id
JOIN employee_territories et ON t.territory_id = et.territory_id
JOIN employees e ON et.employee_id = e.employee_id
GROUP BY r.region_description
ORDER BY total_employees DESC;
","This SQL query analyzes employee distribution across regions by counting the number of employees assigned to each region. It joins the 'region', 'territories', 'employee_territories', and 'employees' tables to track employee assignments through territories to regions. The output shows which regions have the most employee coverage, valuable for workforce planning and regional management. Key operations include multi-table JOINs to connect regions to employees via territories, COUNT aggregation, and GROUP BY for regional grouping. The query can be modified to: 1) include employee roles to analyze specialization by region, 2) add performance metrics to assess regional productivity, or 3) filter by date ranges to track staffing changes over time. It helps answer business questions like 'How are our employees distributed geographically?' and 'Which regions have the strongest workforce presence?'",How many employees are there in each region? Show 'region_description' and 'total_employees'.,Jumlah karyawan per region berapa? Tampilkan 'region_description' dan 'total_employees'.,"['region_description', 'total_employees']"
How much has each customer paid us in total? Show their CompanyName and total as Total.,"SELECT c.company_name, SUM(od.unit_price * od.quantity * (1.0 - od.discount)) AS total FROM customers c INNER JOIN orders o ON c.customer_id = o.customer_id INNER JOIN order_details od ON od.order_id = o.order_id GROUP BY c.company_name ORDER BY total DESC;","This SQL query calculates the total revenue generated by each customer, sorted in descending order by revenue. It joins the 'customers', 'orders', and 'order_details' tables using 'customer_id' and 'order_id', and computes the sum of the product of unit price, quantity, and discount-adjusted values for each customer. The primary metric is 'total', representing the aggregated revenue per customer. The results are grouped by 'company_name' and ordered by total revenue, providing insights into top-performing customers. This query can be modified by (1) adding a date filter to analyze revenue within a specific time period, (2) including customer regions or categories to segment revenue by demographics, or (3) calculating average order value per customer by dividing total revenue by the count of orders. The query helps answer business questions such as identifying key accounts, evaluating customer loyalty, and assessing the impact of discounts on overall revenue.",How much has each customer paid overall? Show 'CompanyName' and total as 'Total'.,Tiap customer udah bayar ke kita totalnya berapa? Tampilkan 'CompanyName' dan totalnya sebagai 'Total'.,"['company_name', 'total']"
"Which top 5 employees are assigned to territories in the most different regions? Show their employee_id, first_name, last_name, and the number of distinct regions as region_count.","SELECT e.employee_id, e.first_name, e.last_name, COUNT(DISTINCT t.region_id) AS region_count
  FROM employees e
  JOIN employee_territories et ON e.employee_id = et.employee_id
  JOIN territories t ON et.territory_id = t.territory_id
  GROUP BY e.employee_id, e.first_name, e.last_name
  ORDER BY region_count DESC
  LIMIT 5;","This SQL query identifies the top 5 employees with the broadest regional coverage by counting the distinct regions they service through their assigned territories. It joins the 'employees', 'employee_territories', and 'territories' tables via employee_id and territory_id relationships, then groups by employee to calculate their unique region count. The query helps assess workforce geographic distribution and identifies employees with diverse regional experience. Key modifications could include: 1) adding performance metrics to analyze if broader coverage correlates with sales success, 2) filtering by time period to track regional expansion patterns, or 3) comparing region counts across departments or job titles. This query helps answer business questions such as: 'Which employees have the most geographically diverse responsibilities?', 'How does regional coverage relate to employee performance metrics?', or 'Are certain regions underrepresented in our workforce distribution?'","Who are the top 5 employees working across the most different regions based on their assigned territories? Show 'employee_id', 'first_name', 'last_name', and 'region_count'.","Siapa 5 karyawan teratas yang menangani wilayah kerja (territory) dari jumlah region yang paling banyak? Tampilkan 'employee_id', 'first_name', 'last_name', dan 'region_count'.","['employee_id', 'first_name', 'last_name', 'region_count']"
What are the top 10 best-selling products based on sales revenue after getting discounted? Show the ProductName and Sales amount.,"SELECT p.product_name, SUM(od.unit_price * od.quantity * (1.0 - od.discount)) AS sales FROM products p INNER JOIN order_details od ON od.product_id = p.product_id GROUP BY p.product_name ORDER BY sales DESC LIMIT 10;","This SQL query identifies the top 10 best-selling products by calculating total sales revenue (unit price multiplied by quantity and adjusted for discount) for each product. It joins the 'products' and 'order_details' tables on product_id, groups results by product_name, and sorts by descending sales. The query provides valuable insights into product performance by revealing highest revenue-generating items. Key modifications could include: 1) adding product categories to analyze performance by category, 2) filtering by date range to examine sales trends over time, or 3) incorporating inventory data to assess sales-to-stock ratios. This query could answer business questions such as: 'Which products contribute most to revenue?', 'How do discounts impact overall sales volume?', or 'What are our most profitable products?'","What are our top 10 most sold products, looking from revenue after getting discounted? Show 'ProductName' and 'Sales amount'.",10 produk paling laku berdasarkan pendapatan setelah didiskonkan? Tampilkan 'ProductName' dan 'Sales amount'.,"['product_name', 'sales']"
"Retrieve the top 1 customer who placed the most expensive single order and show their name along with the total order value. Show customer_name, order_id, and order_value.","SELECT c.contact_name AS customer_name, o.order_id, 
       SUM(od.unit_price * od.quantity * (1 - od.discount)) AS order_value
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_details od ON o.order_id = od.order_id
GROUP BY c.customer_id, c.contact_name, o.order_id
ORDER BY order_value DESC
LIMIT 1;
","This SQL query identifies the highest-value order in the database by calculating the total discounted value of each order. It joins the 'customers', 'orders', and 'order_details' tables to compute the sum of (unit_price × quantity × (1 - discount)) for each order, then returns the single most valuable order. The output helps identify premium customers and high-value transactions for VIP treatment and sales strategy. Key operations include multi-table JOINs, SUM aggregation with discount calculation, and ORDER BY with LIMIT to isolate the top result. The query can be modified to: 1) show top N orders instead of just one, 2) add date filters to find highest-value orders in specific periods, or 3) include product categories to analyze what drives high-value orders. It helps answer business questions like 'What was our most valuable single order?' and 'Which customers make the largest purchases?'","Who top 1 placed the most expensive order? Show 'customer_name', 'order_id', 'order_value'.","Top 1 customer mana yang pernah bikin order paling mahal? Tampilkan 'customer_name', 'order_id', 'order_value'.","['customer_name', 'order_id', 'order_value']"
List the product names and their suppliers for products that have never been ordered. Show product_name and supplier_name.,"SELECT p.product_name, s.company_name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.supplier_id
WHERE p.product_id NOT IN (SELECT DISTINCT product_id FROM order_details);
","This SQL query identifies products that have never been ordered by comparing the products table against order records. It joins the 'products' and 'suppliers' tables to display product-supplier relationships, then uses a NOT IN subquery against the 'order_details' table to find products with no sales history. The output helps inventory management by highlighting potentially obsolete or poorly marketed items. Key operations include a LEFT JOIN between products and suppliers, and a NOT IN subquery to filter out products that appear in orders. The query can be modified to: 1) include product categories to analyze patterns among unsold items, 2) add date filters to find products not sold within specific periods, or 3) calculate inventory holding costs for these products. It helps answer critical business questions like 'Which products are failing to attract customers?' and 'Should we discontinue certain items from our catalog?'",List products that were never ordered and their suppliers. Show 'product_name' and 'supplier_name'.,Produk yang belum pernah diorder dan suppliernya apa aja? Tampilkan 'product_name' dan 'supplier_name'.,"['product_name', 'supplier_name']"
Which year had the highest total order revenue? Show year and total_revenue.,"SELECT EXTRACT(YEAR FROM o.order_date) AS year,
  SUM(od.unit_price * od.quantity * (1 - od.discount)) AS total_revenue
  FROM orders o
  JOIN order_details od ON o.order_id = od.order_id
  GROUP BY year
  ORDER BY total_revenue DESC
  LIMIT 1;","This SQL query identifies the highest-grossing year by calculating total revenue (unit_price × quantity × (1 - discount)) from the 'orders' and 'order_details' tables. It extracts the year from order dates, sums the revenue by year, and returns the year with maximum sales. Key operations include EXTRACT for year isolation, revenue calculation incorporating discounts, SUM aggregation, and ORDER BY with LIMIT. The primary metric 'total_revenue' shows annual sales performance. No additional filters are applied, providing a complete historical analysis. The output pinpoints the company's peak sales year, valuable for business performance evaluation and trend analysis. Potential modifications include: (1) breaking down results by quarter within the top year, (2) comparing revenue against marketing spend by joining budget data, or (3) analyzing product category contributions to the peak year's success. This query could answer questions like 'What was our most profitable year?' or 'How has our annual revenue performance trended over time?'",Which year made the most revenue? Show 'year' and 'total_revenue'.,Tahun mana yang pendapatannya paling tinggi? Tampilkan 'year' dan 'total_revenue'.,"['year', 'total_revenue']"
"Retrieve the orders that were shipped later than the required date. Show order_id, customer_name, and the number of days they were delayed as delay_in_days.","SELECT o.order_id, c.company_name AS customer_name, (o.shipped_date - o.required_date) AS delay_in_days
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.shipped_date > o.required_date;","This SQL query analyzes order fulfillment delays by calculating the difference between shipped and required dates for overdue orders. It joins the 'orders' and 'customers' tables to identify delayed shipments and computes the delay duration in days. The output helps evaluate supply chain performance and customer service issues by highlighting the most significantly delayed orders. Key operations include date arithmetic to calculate delays, a JOIN to connect orders with customers, and a WHERE filter to focus only on late shipments. The query can be modified to: 1) group delays by customer to identify problematic accounts, 2) include product categories to analyze delay patterns by product type, or 3) add order value to assess the financial impact of delays. It helps answer critical business questions like 'Which orders experienced the worst shipping delays?' and 'How does our fulfillment performance impact customer satisfaction?'","Which orders were shipped late? Show 'order_id', 'customer_name', and 'delay_in_days'.","Order mana saja yang dikirim lebih lambat dari tanggal yang diminta? Tampilkan 'order_id', 'customer_name', dan 'delay_in_days' (jumlah hari keterlambatan).","['order_id', 'customer_name', 'delay_in_days']"
"Which top 1 shipper was used the most for deliveries? Show shipper_id, company_name, and shipment_count.","SELECT s.shipper_id, s.company_name, COUNT(o.order_id) AS shipment_count
  FROM shippers s
  JOIN orders o ON s.shipper_id = o.ship_via
  GROUP BY s.shipper_id, s.company_name
  ORDER BY shipment_count DESC
  LIMIT 1;","This SQL query identifies the shipper with the highest number of shipments by joining the 'shippers' and 'orders' tables on 'shipper_id' (aliased as 'ship_via' in orders), counting orders per shipper, and returning the top result by shipment count. Key operations include a JOIN, GROUP BY on shipper details, COUNT aggregation, and ORDER BY with LIMIT to isolate the top performer. The primary metric is 'shipment_count', revealing the most utilized shipper. No filters are applied, making it a broad performance assessment. The output helps logistics teams recognize the most active shipping partner, useful for contract negotiations or service evaluations. Potential modifications include: (1) adding a date filter to analyze recent performance trends, (2) calculating market share percentages among shippers by comparing counts to total orders, or (3) joining with shipment delay data to assess whether high-volume shippers maintain quality. This query could answer questions like 'Which shipping partner handles the most orders?' or 'Is there correlation between shipment volume and delivery performance?'","Which top 1 shipping company was used the most? Show 'shipper_id', 'company_name', 'shipment_count'.","Top 1 shipper mana yang paling sering dipakai? Tampilkan 'shipper_id', 'company_name', 'shipment_count'.","['shipper_id', 'company_name', 'shipment_count']"
"Which customers have ordered more than 10,000 units in total? Show customer_id, company_name, and total_units_ordered.","SELECT c.customer_id, c.company_name, SUM(od.quantity) AS total_units_ordered
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN order_details od ON o.order_id = od.order_id
  GROUP BY c.customer_id, c.company_name
  HAVING SUM(od.quantity) > 10000
  ORDER BY total_units_ordered DESC;","This SQL query identifies high-volume customers by calculating total units ordered per customer, filtering for those who purchased over 10,000 units. It joins the 'customers', 'orders', and 'order_details' tables to connect customer information with order quantities. The query aggregates quantity data using SUM, applies a HAVING filter to focus on bulk purchasers, and sorts results by total units in descending order. Key operations include multi-table JOINs, SUM aggregation, HAVING for post-aggregation filtering, and ORDER BY. The primary metric 'total_units_ordered' highlights purchasing volume, with the HAVING clause isolating significant customers. The output helps identify key accounts for relationship management and sales strategy. Potential modifications include: (1) adding product category filters to analyze purchasing patterns by product type, (2) incorporating date ranges to identify seasonal bulk purchasers, or (3) calculating average order size alongside total volume. This query could answer questions like 'Which customers purchase the largest quantities?' or 'Who are our most important volume customers?'","Which customers ordered over 10,000 units? Show 'customer_id', 'company_name', 'total_units_ordered'.","Customer siapa saja yang total order-nya lebih dari 10.000 unit? Tampilkan 'customer_id', 'company_name', 'total_units_ordered'.","['customer_id', 'company_name', 'total_units_ordered']"
"Which top customer has bought the most different products? Show 'customer_id', 'company_name', and 'distinct_product_count', and return only the top 1 based on the number of distinct products purchased.","SELECT
  c.customer_id,
  c.company_name,
  COUNT(DISTINCT od.product_id) AS distinct_product_count
FROM
  customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_details od ON o.order_id = od.order_id
GROUP BY
  c.customer_id, c.company_name
ORDER BY
  distinct_product_count DESC
LIMIT 1;","This SQL query identifies the customer who has purchased the widest variety of distinct products by counting unique product IDs per customer. It joins the 'customers', 'orders', and 'order_details' tables through customer_id and order_id relationships, then groups results by customer to calculate their distinct product count. The query highlights customer engagement diversity by revealing which company explores the most products in your catalog. Key modifications could include: 1) adding date filters to analyze purchasing patterns during specific periods, 2) setting a minimum order threshold to focus on active customers, or 3) comparing product diversity across customer segments or regions. This query helps answer business questions such as: 'Which customers are most adventurous in trying our product range?', 'Does product diversity correlate with customer loyalty or lifetime value?', or 'Which customer segments might benefit from cross-selling opportunities?'","Who’s the top customer that bought the most different products? Show their customer_id, company_name, and how many unique products they’ve purchased as distinct_product_count. Just return the top one based on that count.","Top 1 customer mana yang membeli produk paling beragam? Tampilkan 'customer_id', 'company_name', dan 'distinct_product_count', dan ambil satu customer teratas berdasarkan jumlah produk berbeda yang dibeli.","['customer_id', 'company_name', 'distinct_product_count']"
"For each customer, show how many different products they have ordered more than once across multiple orders. Display the customer as customer_name and the number of repeated products as repeated_products.","SELECT c.contact_name AS customer_name, COUNT(DISTINCT od.product_id) AS repeated_products
FROM Customers c
JOIN Orders o ON c.customer_id = o.customer_id
JOIN Order_Details od ON o.order_id = od.order_id
GROUP BY c.customer_id, customer_name
HAVING COUNT(*) > 1;","This SQL query identifies customers who repeatedly purchase the same products by counting distinct product IDs per customer and filtering for those with multiple orders. It joins the 'Customers', 'Orders', and 'Order_Details' tables through customer_id and order_id relationships, grouping by customer to find product repetition patterns. The query helps identify customer loyalty and potential product stickiness. Key modifications could include: 1) adding product categories to analyze which types of products are most frequently repurchased, 2) incorporating time intervals between repeat purchases to understand repurchase cycles, or 3) comparing repeat purchase behavior across different customer segments. This query helps answer business questions such as: 'Which products have the highest customer retention rates?', 'Which customers are most loyal to specific products?', or 'How does repeat purchasing behavior vary by product category?'",How many different products has each customer bought more than once? Show customer_name and the number of repeated products as repeated_products.,Berapa banyak produk berbeda yang pernah dibeli lebih dari satu kali oleh setiap customer? Tampilkan customer sebagai customer_name dan jumlah produk yang diulang sebagai repeated_products.,"['customer_name', 'repeated_products']"
What is the average discount given per order? Show order_id and average_discount. Order by order id,"SELECT order_id, AVG(discount) AS average_discount
FROM order_details
GROUP BY order_id
ORDER BY order_id;","This SQL query identifies the top 10 orders with the highest average discount rates by analyzing the 'order_details' table. It calculates the average discount per order and sorts orders by discount magnitude in descending order. Key operations include AVG aggregation, GROUP BY on order_id, and ORDER BY with LIMIT by order_id. The primary metric 'average_discount' reveals discounting patterns at the order level. No filters are applied, providing a complete view of discount practices. The output helps identify orders with unusually high discounts, valuable for pricing strategy analysis and discount policy evaluation. Potential modifications include: (1) joining with customer data to analyze discount patterns by customer segment, (2) adding product category information to see if certain product types receive higher discounts, or (3) comparing discount rates against order sizes to identify volume discount patterns. This query could answer questions like 'Which orders received the deepest discounts?' or 'What is our typical discount range per order?'",What’s the average discount per order? Show 'order_id' and 'average_discount'. Order by id,Rata-rata diskon per order berapa? Tampilkan 'order_id' dan 'average_discount'. Urutkan berdasarkan id,"['order_id', 'average_discount']"
"Which top 1 supplier provide the most products? Show supplier_id, company_name, and product_count.","SELECT s.supplier_id, s.company_name, COUNT(p.product_id) AS product_count
  FROM suppliers s
  JOIN products p ON s.supplier_id = p.supplier_id
  GROUP BY s.supplier_id, s.company_name
  ORDER BY product_count DESC
  LIMIT 1;","This SQL query analyzes supplier product offerings by counting the number of products each supplier provides. It joins the 'suppliers' and 'products' tables on supplier_id, groups the results by supplier, and orders them by product count in descending order and get top 1 with LIMIT. The output helps identify key suppliers based on product volume, which is valuable for supply chain management and procurement strategies. Modifications could include: 1) adding product category filters to analyze supplier specialization, 2) incorporating product availability/discontinued status to assess active offerings, or 3) joining with order data to evaluate supplier performance metrics. This query helps answer questions like 'Which suppliers provide the most products?' and 'How diversified are our supplier relationships?'","Which top 1 supplier offer the most products? Show 'supplier_id', 'company_name', 'product_count'.","Top 1 supplier mana yang punya produk paling banyak? Tampilkan 'supplier_id', 'company_name', 'product_count'.","['supplier_id', 'company_name', 'product_count']"
Find the total number of customers per country and display the results in descending order. Show country and total_customers.,"SELECT country, COUNT(customer_id) AS total_customers
FROM customers
GROUP BY country
ORDER BY total_customers DESC;
","This SQL query analyzes customer distribution by country by counting the number of customers in each country from the 'customers' table. It groups the results by country and sorts them in descending order by customer count, providing a clear view of geographic customer concentration. The output is valuable for market analysis, helping identify strong and weak markets for business strategy and resource allocation. Key operations include COUNT aggregation and GROUP BY for country-level grouping. The query can be modified to: 1) add percentage calculations to show each country's share of total customers, 2) include customer activity metrics to differentiate between active and inactive customers by country, or 3) join with order data to correlate customer count with sales volume. It helps answer important business questions like 'Where is our customer base concentrated geographically?' and 'Which markets should we target for expansion?'","Customers per country, most to least? Show 'country' and 'total_customers'.","Jumlah customer per negara, dari yang paling banyak ke dikit? Tampilkan 'country' dan 'total_customers'.","['country', 'total_customers']"
"What is the average number of orders per customer? Show total_customers, total_orders, and average_orders_per_customer.","SELECT COUNT(DISTINCT c.customer_id) AS total_customers,
  COUNT(o.order_id) AS total_orders,
  CAST(COUNT(*) AS REAL) / COUNT(DISTINCT c.customer_id) AS average_orders_per_customer
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id;","This SQL query calculates key customer engagement metrics by determining the total number of unique customers, total orders placed, and average orders per customer. It joins the 'customers' and 'orders' tables on customer_id, using COUNT(DISTINCT) for unique customers and a division of total orders by unique customers to calculate the average. The query provides foundational insights into customer purchasing behavior and order frequency. Potential modifications include: 1) adding date filters to analyze trends over specific time periods, 2) segmenting by customer demographics or regions by incorporating additional WHERE clauses, or 3) comparing these metrics across different product categories. This query helps answer business questions such as: 'What is our customer base's overall order frequency?', 'How does order volume relate to our customer count?', or 'What's the baseline for customer engagement we should aim to improve?'","On average, how many times each customer order? Show 'total_customers', 'total_orders', 'average_orders_per_customer'.","Rata-rata order per customer berapa? Tampilkan 'total_customers', 'total_orders', 'average_orders_per_customer'.","['total_customers', 'total_orders', 'average_orders_per_customer']"
Which top 3 cities have the highest number of customers? Show city and customer_count.,"SELECT city, COUNT(*) AS customer_count
  FROM customers
  WHERE city IS NOT NULL
  GROUP BY city
  ORDER BY customer_count DESC
  LIMIT 3;","This SQL query identifies the top 3 cities with the highest concentration of customers by counting customers per city in the 'customers' table. It filters out null city values, groups results by city, and returns the most populous customer locations. The output helps businesses understand their strongest local markets for targeted marketing and resource allocation. Key operations include COUNT aggregation, GROUP BY for city-level grouping, and ORDER BY with LIMIT to focus on top results. The query can be modified to: 1) include regional breakdowns for broader geographic analysis, 2) add customer value metrics to identify high-value locations, or 3) filter by customer activity to distinguish between active and inactive customer bases. It helps answer business questions like 'Where are our customer bases concentrated?' and 'Which local markets should we prioritize for expansion?'",Which top 3 cities have the most customers? Show 'city' and 'customer_count'.,Top 3 kota mana yang punya customer paling banyak? Tampilkan 'city' dan 'customer_count'.,"['city', 'customer_count']"
"Show the product name and the reorder level of all products with units in stock that are below their reorder level. Show product_name, units_in_stock, and reorder_level.","SELECT product_name, units_in_stock, reorder_level
FROM products
WHERE units_in_stock < reorder_level;
","This SQL query identifies products that need reordering by comparing current stock levels to reorder thresholds. It queries the 'products' table to find items where 'units_in_stock' falls below the 'reorder_level', helping maintain optimal inventory levels. The output provides a prioritized list for procurement actions, crucial for inventory management and supply chain operations. Key operations include a simple table scan with a WHERE filter comparing two numeric columns. The query can be modified to: 1) include supplier information to facilitate reordering, 2) add product categories to analyze stock issues by category, or 3) calculate how far below reorder level each product is to prioritize urgent orders. It helps answer critical business questions like 'Which products need immediate restocking?' and 'Are our reorder levels set appropriately across product lines?'","Which products are below reorder level in stock? Show 'product_name', 'units_in_stock', 'reorder_level'.","Produk apa aja yang stoknya udah di bawah level reorder? Tampilkan 'product_name', 'units_in_stock', 'reorder_level'.","['product_name', 'units_in_stock', 'reorder_level']"
