Question,Answer,Summary,Alternative Prompt 1 (English),Alternative Prompt 2 (Bahasa Indonesia),Expected Result
"Which top 1 product has generated the highest revenue? Show product_id, product_name, and revenue.","SELECT p.product_id, p.product_name,
  SUM(od.unit_price * od.quantity * (1 - od.discount)) AS revenue
  FROM products p
  JOIN order_details od ON p.product_id = od.product_id
  GROUP BY p.product_id, p.product_name
  ORDER BY revenue DESC
  LIMIT 1;","This SQL query identifies the highest-grossing product by calculating total revenue (unit_price × quantity × (1 - discount)) from the 'products' and 'order_details' tables, joined on product_id. It aggregates revenue by product and returns the top performer. Key operations include a table JOIN, revenue calculation incorporating discounts, SUM aggregation, and ORDER BY with LIMIT. The primary metric is 'revenue', showing each product's total sales value. No filters are applied, providing a complete product performance analysis. The output helps identify best-selling products for inventory and marketing decisions. Potential modifications include: (1) adding a date filter to analyze seasonal performance, (2) calculating profit by incorporating product cost data, or (3) grouping by product category to identify top-performing categories. This query could answer questions like 'What is our highest-revenue product?' or 'How do products rank by sales performance?'","Which top 1 product made the most money? Show 'product_id', 'product_name', 'revenue'.","Top 1 produk mana yang hasilin duit paling banyak? Tampilkan 'product_id', 'product_name', 'revenue'.","['product_id', 'product_name', 'revenue']"
"Find the employees who manage territories in more than one region and show their names along with the number of regions they manage. Show first_name, last_name, and total_regions.","SELECT e.first_name, e.last_name, COUNT(DISTINCT r.region_id) AS total_regions
FROM employees e
JOIN employee_territories et ON e.employee_id = et.employee_id
JOIN territories t ON et.territory_id = t.territory_id
JOIN region r ON t.region_id = r.region_id
GROUP BY e.employee_id, e.first_name, e.last_name
HAVING COUNT(DISTINCT r.region_id) > 1
ORDER BY total_regions DESC;
","This SQL query identifies employees who work across multiple regions by analyzing territory assignments. It joins the 'employees', 'employee_territories', 'territories', and 'region' tables to count distinct regions per employee, filtering for those covering more than one region. The output helps evaluate workforce flexibility and cross-regional expertise, which is valuable for resource allocation and team structuring. Key operations include multi-table JOINs, COUNT(DISTINCT) for unique region counting, and HAVING for filtering multi-region employees. The query can be modified to: 1) include performance metrics to assess effectiveness across regions, 2) add date ranges to analyze regional coverage trends, or 3) incorporate customer data to evaluate multi-region customer support. It helps answer business questions like 'Which employees have the most diverse regional experience?' and 'How effectively are we utilizing cross-regional staff?'","Which employees are assigned to territories that belong to more than one region? Show 'first_name', 'last_name', and the number of unique regions as 'total_regions'.","Karyawan siapa saja yang ngurus territory di lebih dari 1 region? Tampilkan 'first_name', 'last_name', 'total_regions'.","['first_name', 'last_name', 'total_regions']"
Which customers have not placed any orders? Show customer_id and company_name.,"SELECT c.customer_id, c.company_name
  FROM customers c
  LEFT JOIN orders o ON c.customer_id = o.customer_id
  WHERE o.order_id IS NULL;","This SQL query identifies customers who have never placed an order by performing a LEFT JOIN between the 'customers' and 'orders' tables and filtering for NULL order IDs. The output provides a list of inactive customers, which is valuable for customer retention and marketing efforts. Key operations include a LEFT JOIN to preserve all customers and IS NULL check to identify non-ordering customers. The query can be modified to: 1) include customer registration dates to analyze how long they've been inactive, 2) add demographic data to identify patterns among non-ordering customers, or 3) join with contact history to evaluate engagement attempts. It helps answer business questions like 'Which customers have never made a purchase?' and 'How can we better engage our inactive customer base?'",Which customers never ordered anything? Show 'customer_id' and 'company_name'.,Customer mana yang belum pernah order sama sekali? Tampilkan 'customer_id' dan 'company_name'.,"['customer_id', 'company_name']"
Find top 1 popular category of products based on total quantity ordered. Show category_name and total_quantity.,"SELECT c.category_name, SUM(od.quantity) AS total_quantity
FROM order_details od
JOIN products p ON od.product_id = p.product_id
JOIN categories c ON p.category_id = c.category_id
GROUP BY c.category_name
ORDER BY total_quantity DESC
LIMIT 1;
","This SQL query identifies the best-selling product category by total quantity sold. It joins the 'order_details', 'products', and 'categories' tables to calculate the sum of quantities sold per category, then returns only the top-performing category. The output helps businesses understand which product categories drive the most volume, informing inventory and marketing strategies. Key operations include multi-table JOINs, SUM aggregation, and LIMIT to focus on the top result. The query can be modified to: 1) show top N categories instead of just one, 2) add date filters to analyze seasonal trends, or 3) include revenue calculations by incorporating unit prices. It helps answer business questions like 'Which product category sells the most units?' and 'Where should we focus our inventory investments?'",Top 1 popular category by quantity ordered? Show 'category_name' and 'total_quantity'.,Top 1 kategori produk paling populer berdasarkan jumlah order? Tampilkan 'category_name' dan 'total_quantity'.,"['category_name', 'total_quantity']"
What are the top 3 cities with the highest number of orders? Show city and total_orders.,"SELECT ship_city AS city, COUNT(order_id) AS total_orders
  FROM orders
  WHERE ship_city IS NOT NULL
  GROUP BY ship_city
  ORDER BY total_orders DESC
  LIMIT 3;","This SQL query identifies the top 3 cities with the highest number of orders by analyzing the 'orders' table. It counts orders per city (excluding NULL values), groups by 'ship_city', and returns the cities with the most orders in descending order. Key operations include COUNT aggregation, GROUP BY, and ORDER BY with LIMIT. The primary metric is 'total_orders', showing order volume by destination city. The WHERE clause filters out NULL values to ensure data quality. The output helps identify key markets and shipping destinations, valuable for logistics planning and regional sales analysis. Potential modifications include: (1) adding a date filter to analyze recent order trends by city, (2) joining with customer data to differentiate between business and consumer orders, or (3) calculating order value by city by incorporating order_details data. This query could answer questions like 'Which cities receive the most orders?' or 'Where should we focus our shipping infrastructure improvements?'",Top 3 cities with the most orders? Show 'city' and 'total_orders'.,3 kota dengan jumlah order terbanyak? Tampilkan 'city' dan 'total_orders'.,"['city', 'total_orders']"
"Get the number of orders handled per shipper per year. Show shipper_name, order_year, and order_count.","SELECT s.company_name AS shipper_name,
       EXTRACT(YEAR FROM o.order_date) AS order_year,
       COUNT(o.order_id) AS order_count
FROM orders o
JOIN shippers s ON o.ship_via = s.shipper_id
GROUP BY s.company_name, order_year
ORDER BY shipper_name, order_year;","This SQL query analyzes shipping company performance by counting the number of orders handled per shipper per year. It joins the 'orders' and 'shippers' tables, extracts the year from order dates, and groups the results by shipper and year. The output provides valuable insights into shipping partner utilization and yearly trends, helping businesses evaluate carrier performance and make logistics decisions. Key operations include a table JOIN, EXTRACT for year isolation, COUNT aggregation, and multi-column GROUP BY. The query can be modified to: 1) add order value metrics to assess shipping cost efficiency, 2) include month-level granularity for seasonal analysis, or 3) filter by shipping region to evaluate geographic performance. It helps answer business questions like 'Which shippers handle the most volume?' and 'How has shipper usage changed year-over-year?'","How many orders per shipper per year? Show 'shipper_name', 'order_year', 'order_count'.","Jumlah order per shipper per tahun berapa aja? Tampilkan 'shipper_name', 'order_year', 'order_count'.","['shipper_name', 'order_year', 'order_count']"
"Which products are currently out of stock? Show product_id, product_name, and units_in_stock.","SELECT product_id, product_name, units_in_stock
  FROM products
  WHERE units_in_stock = 0;","This SQL query identifies out-of-stock products by selecting records from the 'products' table where units_in_stock equals 0. It returns the product_id, product_name, and units_in_stock for these items. The query uses a simple WHERE filter to isolate products with zero inventory. The output provides a clear list of products needing restocking, which is critical for inventory management and supply chain operations. Potential modifications include: (1) adding product category information to identify which categories have the most out-of-stock items, (2) including supplier details to facilitate reordering, or (3) filtering for products that are both out-of-stock and currently on promotion. This query could answer questions like 'Which products need immediate restocking?' or 'Are there particular product categories that frequently run out of stock?'","Which products are out of stock now? Show 'product_id', 'product_name', 'units_in_stock'.","Produk apa aja yang lagi kosong stoknya? Tampilkan 'product_id', 'product_name', 'units_in_stock'.","['product_id', 'product_name', 'units_in_stock']"
"Which top 1 employee manages the most other employees? Show employee_id, first_name, last_name, and report_count.","SELECT e.employee_id, e.first_name, e.last_name, COUNT(e2.employee_id) AS report_count
  FROM employees e
  JOIN employees e2 ON e.employee_id = e2.reports_to
  GROUP BY e.employee_id, e.first_name, e.last_name
  ORDER BY report_count DESC
  LIMIT 1;","This SQL query identifies the employee with the most direct reports by performing a self-join on the 'employees' table. It counts how many employees report to each manager (where e.employee_id = e2.reports_to), groups by manager attributes, and returns the manager with the highest count. Key operations include a self-JOIN, COUNT aggregation, GROUP BY on employee details, and ORDER BY with LIMIT to isolate the top manager. The primary metric 'report_count' reveals organizational structure and management spans. No filters are applied, providing a complete view of reporting relationships. The output helps identify key managerial roles with the widest spans of control, useful for organizational analysis and leadership development. Potential modifications include: (1) adding hierarchical level tracking to analyze multi-level reporting structures, (2) comparing report counts against team performance metrics, or (3) filtering by department to identify management density in specific areas. This query could answer questions like 'Who has the largest team in our organization?' or 'How are reporting responsibilities distributed among managers?'","Which top 1 employee manages the most subordinates? Show 'employee_id', 'first_name', 'last_name', 'report_count'.","Top 1 karyawan mana yang punya bawahan paling banyak? Tampilkan 'employee_id', 'first_name', 'last_name', 'report_count'.","['employee_id', 'first_name', 'last_name', 'report_count']"
"Find the names of employees who have handled at least 10 orders, along with the total number of orders they processed. Show first_name, last_name, and total_orders_handled.","SELECT e.first_name, e.last_name, COUNT(o.order_id) AS total_orders_handled
FROM employees e
JOIN orders o ON e.employee_id = o.employee_id
GROUP BY e.employee_id, e.first_name, e.last_name
HAVING COUNT(o.order_id) >= 10;","This SQL query identifies high-performing employees by counting the number of orders each employee has handled, filtering for those with 10 or more orders. It joins the 'employees' and 'orders' tables, groups the results by employee, and applies a HAVING clause to focus on productive staff members. The output helps recognize top performers and evaluate workforce productivity. Key operations include a table JOIN, COUNT aggregation, and HAVING for post-aggregation filtering. The query can be modified to: 1) add date ranges to analyze recent performance, 2) include order value metrics to assess revenue impact, or 3) join with customer data to evaluate customer retention rates. It helps answer business questions like 'Who are our most productive employees?' and 'What is the order handling capacity of our staff?'","Who handled at least 10 orders? Show 'first_name', 'last_name', 'total_orders_handled'.","Karyawan siapa saja yang udah ngurus minimal 10 order? Tampilkan 'first_name', 'last_name', 'total_orders_handled'.","['first_name', 'last_name', 'total_orders_handled']"
"Which top 5 suppliers ship the highest average priced products? Show supplier_id, company_name, and average_price.","SELECT s.supplier_id, s.company_name, AVG(p.unit_price) AS average_price
FROM suppliers s
JOIN products p ON s.supplier_id = p.supplier_id
GROUP BY s.supplier_id, s.company_name
ORDER BY average_price DESC
LIMIT 5;","This SQL query identifies the top 5 suppliers with the highest average product prices by joining the 'suppliers' and 'products' tables. It calculates the average unit price per supplier and sorts suppliers by this average in descending order. Key operations include a table JOIN, AVG aggregation, and ORDER BY with LIMIT to focus on the top performers. The primary metric 'average_price' reveals pricing strategies across suppliers. No filters are applied, providing a comprehensive supplier price analysis. The output helps procurement teams identify premium suppliers and assess pricing strategies, valuable for cost management and supplier negotiations. Potential modifications include: (1) adding product category filters to analyze prices within specific categories, (2) comparing average prices against product quality ratings, or (3) calculating price ranges (min/max) per supplier to understand pricing consistency. This query could answer questions like 'Which suppliers provide the most expensive products on average?' or 'How do supplier pricing strategies compare?'","Which top 5 suppliers ship the priciest stuff on average? Show 'supplier_id', 'company_name', 'average_price'.","Top 5 supplier mana yang ngirim produk paling mahal rata-rata? Tampilkan 'supplier_id', 'company_name', 'average_price'.","['supplier_id', 'company_name', 'average_price']"
"Which top 1 employee has the highest total sales amount? Show employee_id, first_name, last_name, and total_sales.","SELECT e.employee_id, e.first_name, e.last_name,
  SUM(od.unit_price * od.quantity * (1 - od.discount)) AS total_sales
  FROM employees e
  JOIN orders o ON e.employee_id = o.employee_id
  JOIN order_details od ON o.order_id = od.order_id
  GROUP BY e.employee_id, e.first_name, e.last_name
  ORDER BY total_sales DESC
  LIMIT 1;","This SQL query identifies the top-performing employee by total sales revenue by joining the 'employees', 'orders', and 'order_details' tables. It calculates net sales (unit_price × quantity × (1 - discount)) for each employee, sums these values, and returns the employee with the highest sales. Key operations include multi-table JOINs, arithmetic calculations with discount application, SUM aggregation, and ORDER BY with LIMIT to isolate the top performer. The primary metric is 'total_sales', representing the complete revenue generated per employee. No filters are applied, providing a comprehensive performance assessment. The output helps recognize top sales contributors, useful for performance evaluation and incentive planning. Potential modifications include: (1) adding a date filter to analyze sales performance for specific periods, (2) calculating average order value per employee by dividing total sales by order count, or (3) joining with customer data to analyze sales by customer segments. This query could answer questions like 'Who is our highest-grossing sales employee?' or 'How do employee sales performances compare?'","Who top 1 sold the most? Show 'employee_id', 'first_name', 'last_name', 'total_sales'.","Top 1 karyawan mana yang hasilin penjualan paling gede? Tampilkan 'employee_id', 'first_name', 'last_name', 'total_sales'.","['employee_id', 'first_name', 'last_name', 'total_sales']"
"How much revenue has each customer generated in total, including those who made no purchases, and how much of that revenue came specifically from the year 1997? Please show the CustomerID, CompanyName, and Country, along with the total revenue labeled as Customer Total and the revenue from 1997 labeled as 1997, ordered by Customer Total.","SELECT c.customer_id, c.company_name, c.country, COALESCE(SUM(od.unit_price * od.quantity * (1.0 - od.discount)), 0) AS customer_total, COALESCE((SELECT SUM(od2.unit_price * od2.quantity * (1.0 - od2.discount)) FROM orders o2 JOIN order_details od2 ON o2.order_id = od2.order_id WHERE o2.customer_id = c.customer_id AND EXTRACT(YEAR FROM o2.order_date) = 1997), 0) AS revenue_1997 FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN order_details od ON od.order_id = o.order_id GROUP BY c.customer_id, c.company_name, c.country ORDER BY customer_total;","This SQL query analyzes customer spending patterns by calculating total lifetime revenue and 1997-specific revenue for each customer. It joins the 'customers', 'orders', and 'order_details' tables using LEFT JOINs to include all customers (even those without orders), calculates discounted order totals (unit_price * quantity * (1 - discount)), and uses a correlated subquery to isolate 1997 revenue. Key features include COALESCE to handle null values, EXTRACT for year filtering, and LEFT JOINs to preserve all customers. The output helps identify high-value customers and year-over-year spending changes. Modifications could include: 1) adding more year-specific columns for trend analysis, 2) comparing 1997 revenue to lifetime averages, or 3) filtering by country/region. This query answers questions like 'Which customers are our biggest spenders overall?' and 'How did 1997 revenue compare to lifetime spending patterns?'","How much has each customer paid in total, including those who didn’t make any purchases, and how much of that was paid in 1997? Please include the CustomerID, CompanyName, and Country, and show the total revenue as Customer Total and the 1997 revenue as 1997, sorted by Customer Total.","Berapa total pembayaran yang dilakukan oleh setiap customer, termasuk yang tidak melakukan pembelian sama sekali, dan berapa yang berasal dari tahun 1997? Tampilkan CustomerID, CompanyName, dan Country, serta total pendapatan sebagai Customer Total dan pendapatan tahun 1997 sebagai 1997, urutkan berdasarkan Customer Total.","['customer_id', 'company_name', 'country', 'customer_total', 'revenue_1997']"
Find the employees who have never handled any orders and display their first name and last name. Show first_name and last_name.,"SELECT first_name, last_name
FROM employees
WHERE employee_id NOT IN (SELECT DISTINCT employee_id FROM orders);
","This SQL query identifies employees who haven't processed any orders by comparing the employees table against order records. It uses the 'employees' table with a subquery against the 'orders' table to find employees with no order assignments. The output helps HR and management identify underutilized staff or potential training needs. Key operations include a NOT IN clause with a subquery to find non-matching records. The query can be modified to: 1) include hire dates to analyze if non-participation correlates with tenure, 2) add department information to spot departmental patterns, or 3) join with other activity tables to check for non-sales contributions. It helps answer important questions like 'Which employees aren't engaged in order processing?' and 'Are there staffing imbalances in our order workflow?'",Which employees never handled any orders? Show 'first_name' and 'last_name'.,Siapa aja karyawan yang belum pernah ngurus order? Tampilkan 'first_name' dan 'last_name'.,"['first_name', 'last_name']"
"What are the total units sold per product? Show product_id, product_name, and total_units_sold.","SELECT p.product_id, p.product_name, SUM(od.quantity) AS total_units_sold
  FROM products p
  JOIN order_details od ON p.product_id = od.product_id
  GROUP BY p.product_id, p.product_name
  ORDER BY total_units_sold DESC;","This SQL query analyzes product sales performance by calculating total units sold for each product. It joins the 'products' and 'order_details' tables on product_id, aggregates the sum of quantities sold, and sorts results in descending order by sales volume. The output identifies best-selling products, which is crucial for inventory management and sales strategy. Key operations include a JOIN between product and order data, SUM aggregation of quantities, and ORDER BY for ranking. The query can be modified by: 1) adding date filters to analyze sales trends over time, 2) including category information to compare performance across product types, or 3) calculating revenue by incorporating unit prices. It helps answer business questions like 'What are our top-selling products?' and 'Which items should we prioritize for inventory stocking?'","How many units sold for each product? Show 'product_id', 'product_name', 'total_units_sold'.","Total unit terjual per produk? Tampilkan 'product_id', 'product_name', 'total_units_sold'.","['product_id', 'product_name', 'total_units_sold']"
Which customers from the UK have paid us more than $1000 in total? Show ContactName and Payments.,"SELECT c.contact_name,
       SUM(od.unit_price * od.quantity * (1.0 - od.discount)) AS payments
FROM customers c
INNER JOIN orders o ON o.customer_id = c.customer_id
INNER JOIN order_details od ON od.order_id = o.order_id
WHERE c.country = 'UK'
GROUP BY c.contact_name
HAVING SUM(od.unit_price * od.quantity * (1.0 - od.discount)) > 1000;","This SQL query identifies UK-based customers who have made total payments exceeding £1000 by calculating the sum of their order values (unit price multiplied by quantity and adjusted for discount). It joins the 'customers', 'orders', and 'order_details' tables using customer_id and order_id, filters for UK customers, and groups results by contact_name with a HAVING clause to focus on high-value customers. The output helps identify key accounts for targeted marketing or loyalty programs. Key modifications could include: 1) adding order dates to analyze spending patterns over time, 2) comparing UK customer spending to other regions by adjusting the country filter, or 3) incorporating product categories to understand purchasing preferences. This query could answer business questions such as: 'Who are our most valuable UK customers?', 'How does discounting affect customer spending thresholds?', or 'What's the minimum spend threshold that identifies our top 20% of customers?'",Which UK customers paid more than $1000? Show 'ContactName' and 'Payments'.,Customer dari UK yang bayar lebih dari $1000 siapa aja? Tampilkan 'ContactName' dan 'Payments'.,"['contact_name', 'payments']"
What are the top 5 countries by total number of customers? Show country and total_customers.,"SELECT country, COUNT(customer_id) AS total_customers
  FROM customers
  GROUP BY country
  ORDER BY total_customers DESC
  LIMIT 5;","This SQL query identifies the top 5 countries with the highest customer counts by aggregating customer data from the 'customers' table. Key operations include COUNT aggregation, GROUP BY for country-level grouping, and ORDER BY with LIMIT to focus on the top results. The output provides valuable market penetration insights, helping businesses understand their strongest geographic markets. Modifications could include: 1) adding percentage calculations to show country share of total customers, 2) filtering by customer activity date to analyze recent growth trends, or 3) joining with order data to correlate customer count with sales volume. This query helps answer questions like 'Where is our customer base concentrated geographically?' and 'Which markets show the strongest customer acquisition?'",Top 5 countries with the most customers? Show 'country' and 'total_customers'.,5 negara dengan jumlah customer terbanyak? Tampilkan 'country' dan 'total_customers'.,"['country', 'total_customers']"
"Find the product that have been ordered the least, showing the product name and total quantity ordered. Show product_name and total_quantity_ordered.","SELECT p.product_name, COALESCE(SUM(od.quantity), 0) AS total_quantity_ordered
FROM products p
LEFT JOIN order_details od ON p.product_id = od.product_id
GROUP BY p.product_name
ORDER BY total_quantity_ordered ASC
LIMIT 1;
","This SQL query identifies the product with the lowest sales volume by counting total quantities ordered for each product. It uses a LEFT JOIN between the 'products' and 'order_details' tables to ensure all products are included (even those never ordered), calculates the sum of quantities ordered, and returns the single worst-performing product. The output helps identify underperforming inventory that may need promotional support or discontinuation. Key operations include a LEFT JOIN to preserve all products, COALESCE to handle null values, SUM aggregation, and ORDER BY with LIMIT to isolate the bottom result. The query can be modified to: 1) show bottom N products instead of just one, 2) add date filters to analyze recent performance trends, or 3) include product categories to identify weak product lines. It helps answer business questions like 'Which product sells the least?' and 'What inventory should we review for potential discontinuation?'",Which product got ordered the least? Show 'product_name' and 'total_quantity_ordered'.,Produk yang paling jarang diorder apa? Tampilkan 'product_name' dan 'total_quantity_ordered'.,"['product_name', 'total_quantity_ordered']"
Show the name of every customer (not company) and how many different employees have handled their orders. Show customer_name and employee_count.,"SELECT c.contact_name AS customer_name, COUNT(DISTINCT o.employee_id) AS employee_count
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.contact_name
ORDER BY employee_count DESC;","This SQL query analyzes customer-employee relationships by counting how many distinct employees have handled orders for each customer. It joins the 'customers' and 'orders' tables, groups by customer, and counts the unique employee IDs associated with each customer's orders. The output reveals which customers interact with the most employees, potentially indicating complex accounts or varied purchasing patterns. Key operations include a table JOIN, COUNT(DISTINCT) to identify unique relationships, and ORDER BY to highlight customers with the most employee interactions. The query can be modified to: 1) add time filters to analyze relationship changes over time, 2) include order volume to assess if multiple handlers correlate with order frequency, or 3) join with employee data to identify specific sales teams involved. It helps answer questions like 'Which customers require the most employee attention?' and 'How specialized are our customer relationships?'","Show customers (not company) and how many employees they’ve dealt with. Show 'customer_name', 'employee_count'.",Tampilkan nama customer (bukan nama perusahaan) dan berapa banyak karyawan berbeda yang pernah menangani pesanan mereka. Tampilkan 'customer_name' dan 'employee_count'.,"['customer_name', 'employee_count']"
Show the total number of orders per shipping country. Show ship_country and total_orders.,"SELECT ship_country, COUNT(order_id) AS total_orders
FROM orders
GROUP BY ship_country
ORDER BY total_orders DESC;
","This SQL query analyzes order distribution by country by counting the number of orders shipped to each destination country. It aggregates data from the 'orders' table, groups results by ship_country, and sorts countries by order volume in descending order. The output provides valuable geographic sales insights, helping businesses understand their strongest international markets. Key operations include COUNT aggregation, GROUP BY for country-level grouping, and ORDER BY for ranking. The query can be modified to: 1) add date filters to analyze shipping trends over time, 2) include order value calculations to assess revenue by country, or 3) join with customer data to evaluate local vs. international sales. It helps answer business questions like 'Which countries receive the most orders?' and 'Where should we focus international marketing efforts?'",Total orders per country shipped to? Show 'ship_country' and 'total_orders'.,Jumlah order per negara tujuan pengiriman berapa aja? Tampilkan 'ship_country' dan 'total_orders'.,"['ship_country', 'total_orders']"
"Which top 1 category has the most products? Show category_id, category_name, and product_count.","SELECT c.category_id, c.category_name, COUNT(p.product_id) AS product_count
  FROM categories c
  JOIN products p ON c.category_id = p.category_id
  GROUP BY c.category_id, c.category_name
  ORDER BY product_count DESC
  LIMIT 1;","This SQL query identifies the product category with the highest number of products by joining the 'categories' and 'products' tables on category_id. It counts products per category and returns the category with the maximum product count. Key operations include a table JOIN, COUNT aggregation, GROUP BY on category attributes, and ORDER BY with LIMIT to isolate the top category. The primary metric is 'product_count', revealing product distribution across categories. No filters are applied, providing a complete inventory analysis. The output helps identify the largest product category, useful for inventory management and category strategy. Potential modifications include: (1) adding a filter for active/discontinued products to analyze only current inventory, (2) calculating the percentage of total products each category represents, or (3) joining with sales data to compare product count against actual sales performance. This query could answer questions like 'Which category has the most products?' or 'How is our product inventory distributed across categories?'","Which top 1 category has the most products? Show 'category_id', 'category_name', 'product_count'.","Top 1 kategori mana yang punya produk paling banyak? Tampilkan 'category_id', 'category_name', 'product_count'.","['category_id', 'category_name', 'product_count']"
Which top 1 region has the most territories? Show region_id and total_territories.,"SELECT r.region_id, COUNT(t.territory_id) AS total_territories
  FROM region r
  JOIN territories t ON r.region_id = t.region_id
  GROUP BY r.region_id
  ORDER BY total_territories DESC
  LIMIT 1;","This SQL query counts the number of territories per region by joining the 'region' and 'territories' tables on 'region_id', grouping the results by region, and ordering them by territory count in descending order and getting top 1 with LIMIT. The primary metric is the count of territories ('total_territories') for each region, providing a simple distribution analysis. No filters are applied, making it a comprehensive count across all regions. The output helps identify which regions have the most territories, useful for sales territory planning or resource allocation. Potential modifications include: (1) adding a WHERE clause to focus on specific regions or territories, (2) extending the query to calculate the percentage of total territories each region represents, or (3) joining with additional tables to incorporate demographic or performance data per region. This query could answer questions like 'Which regions have the highest territory coverage?' or 'How are territories distributed across regions?'",Which top 1 region have the most territories? Show 'region_id' and 'total_territories'.,Top 1 region mana yang punya territory paling banyak? Tampilkan 'region_id' dan 'total_territories'.,"['region_id', 'total_territories']"
What is the monthly revenue in 1997? Show month and monthly_revenue.,"SELECT
  to_char(o.order_date, 'YYYY-MM') AS month,
  SUM(od.unit_price * od.quantity * (1 - od.discount)) AS monthly_revenue
FROM orders AS o
JOIN order_details AS od
  ON o.order_id = od.order_id
WHERE
  EXTRACT(YEAR FROM o.order_date) = 1997
GROUP BY
  month
ORDER BY
  month;","This SQL query analyzes monthly revenue trends for the year 1997 by calculating the sum of order values (unit price multiplied by quantity and adjusted for discount) grouped by month. It joins the 'orders' and 'order_details' tables on order_id, filters for the year 1997 using EXTRACT, and formats the output with month-year labels. The query provides valuable insights into seasonal sales patterns and revenue performance. Key modifications could include: 1) expanding the date range or comparing multiple years to identify trends, 2) adding product categories to analyze revenue by product type, or 3) incorporating customer segments to understand purchasing behavior differences. This query helps answer business questions such as: 'What were our highest and lowest revenue months in 1997?', 'How did discounts impact overall revenue patterns?', or 'What seasonal trends should we anticipate for inventory planning?'","Monthly revenue for 1997? Show 'month', 'monthly_revenue'.",Pendapatan per bulan selama 1997? Tampilkan 'month' dan 'monthly_revenue'.,"['month', 'monthly_revenue']"
"Which product category has the highest average price? Show category_id, category_name, and average_price.","SELECT c.category_id, c.category_name, AVG(p.unit_price) AS average_price
FROM categories c
JOIN products p ON c.category_id = p.category_id
GROUP BY c.category_id, c.category_name
ORDER BY average_price DESC
LIMIT 1;","This SQL query identifies the product category with the highest average unit price by joining the 'categories' and 'products' tables. It calculates the average price per category and returns the category with the maximum average price. Key operations include a table JOIN, AVG aggregation, and ORDER BY with LIMIT to isolate the top category. The primary metric 'average_price' reveals pricing differences across product categories. No filters are applied, providing a comprehensive category price analysis. The output helps identify premium product categories, useful for pricing strategy and product positioning. Potential modifications include: (1) adding a filter for discontinued products to focus only on current offerings, (2) comparing average prices against sales volume to identify price elasticity, or (3) calculating price ranges (min/max) per category to understand pricing consistency. This query could answer questions like 'Which product category commands the highest average price?' or 'How do our product categories compare in terms of pricing?'","Which product category has the highest average price? Show 'category_id', 'category_name', 'average_price'.","Top 1 kategori produk mana yang harga rata-ratanya paling tinggi? Tampilkan 'category_id', 'category_name', 'average_price'.","['category_id', 'category_name', 'average_price']"
Show the total number of customers in each region. Show region and total_customers.,"SELECT c.region, COUNT(c.customer_id) AS total_customers
FROM customers c
GROUP BY c.region
","This SQL query analyzes customer distribution by region by counting the number of customers in each region from the 'customers' table. It groups the results by region and calculates the total customers per region, providing insights into geographic customer concentration. The output is valuable for regional sales strategy and resource allocation decisions. Key operations include COUNT aggregation and GROUP BY for regional grouping. The query can be modified to: 1) add percentage calculations to show each region's share of total customers, 2) include customer activity metrics to differentiate between active and inactive customers by region, or 3) join with order data to correlate customer count with sales volume. It helps answer business questions like 'Where is our customer base concentrated geographically?' and 'Which regions should we target for expansion?'",How many customers are there per region? Show 'region' and 'total_customers'.,Jumlah customer per region berapa? Tampilkan 'region' dan 'total_customers'.,"['region', 'total_customers']"
"Which top 1 shipper has the highest average freight cost per order? Show shipper_id, company_name, and avg_freight.","SELECT s.shipper_id, s.company_name, AVG(o.freight) AS avg_freight
FROM shippers s
JOIN orders o ON s.shipper_id = o.ship_via
GROUP BY s.shipper_id, s.company_name
ORDER BY avg_freight DESC
LIMIT 1;","This SQL query identifies the shipper with the highest average freight costs by analyzing order data. It joins the 'shippers' and 'orders' tables, calculates the average freight cost per shipper, and returns the shipper with the highest average. The output helps evaluate shipping costs and negotiate better rates with carriers. Key operations include a table JOIN, AVG aggregation, and ORDER BY with LIMIT to identify the top result. The query can be modified to: 1) include date ranges to analyze cost trends over time, 2) add order volume metrics to assess cost-effectiveness, or 3) compare freight costs by destination regions. It helps answer business questions like 'Which shipping provider is the most expensive on average?' and 'How can we optimize our shipping costs?'","Which top 1 shipper has the highest average freight cost? Show 'shipper_id', 'company_name', 'avg_freight'.","Top 1 shipper mana yang ongkir rata-ratanya paling mahal? Tampilkan 'shipper_id', 'company_name', 'avg_freight'.","['shipper_id', 'company_name', 'avg_freight']"
